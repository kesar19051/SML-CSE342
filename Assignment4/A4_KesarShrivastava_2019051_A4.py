# -*- coding: utf-8 -*-
"""SML4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dFwXJNcSJn8zm1X5GiM09r3cV71qsAiv
"""

from google.colab import drive
drive.mount('/content/drive/')

import pandas as pd
import numpy as np
import gzip
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import DecisionTreeRegressor
import random
import tensorflow as tf
from keras.models import Sequential
from keras.models import load_model
from keras.layers import Dropout
from keras.layers import Dense, Activation
from tensorflow.keras.layers import BatchNormalization
from keras import initializers
from keras import optimizers
from tensorflow.keras.utils import to_categorical
from sklearn.metrics import accuracy_score
import matplotlib.pyplot as plt
import math
import torch
import pickle

def accuracy(pred, test):
  length = len(pred)
  num = 0
  for i in range(length):
    if pred[i]==test[i]:
      num += 1
  return num/(length*1.0)

def classWiseAccuracy(y_t,y_p):
  pred = []
  test = []
  for i in range(10):
    pred.append([])
    test.append([])

  for i in range(len(y_p)):
    cls = y_t[i]
    pred[cls].append(y_t[i])
    test[cls].append(y_p[i])

  for i in range(10):
    print('Class'+str(i), end = ' ')
    print(accuracy_score(test[i],pred[i]))

def images_file_read(file_name):
    with gzip.open(file_name, 'r') as f:
        # first 4 bytes is a magic number
        magic_number = int.from_bytes(f.read(4), 'big')
        # second 4 bytes is the number of images
        image_count = int.from_bytes(f.read(4), 'big')
        # third 4 bytes is the row count
        row_count = int.from_bytes(f.read(4), 'big')
        # fourth 4 bytes is the column count
        column_count = int.from_bytes(f.read(4), 'big')
        # rest is the image pixel data, each pixel is stored as an unsigned byte
        # pixel values are 0 to 255
        image_data = f.read()
        images = np.frombuffer(image_data, dtype=np.uint8)\
            .reshape((image_count, row_count, column_count))
        return images
def labels_file_read(file_name):
    with gzip.open(file_name, 'r') as f:
        # first 4 bytes is a magic number
        magic_number = int.from_bytes(f.read(4), 'big')
        # second 4 bytes is the number of labels
        label_count = int.from_bytes(f.read(4), 'big')
        # rest is the label data, each label is stored as unsigned byte
        # label values are 0 to 9
        label_data = f.read()
        labels = np.frombuffer(label_data, dtype=np.uint8)
        return labels

"""#Question 1"""

X_train = images_file_read("/content/drive/MyDrive/SML/mnist/train-images-idx3-ubyte.gz")
print(X_train.shape)
y_train = labels_file_read("/content/drive/MyDrive/SML/mnist/train-labels-idx1-ubyte.gz")
X_test = images_file_read("/content/drive/MyDrive/SML/mnist/t10k-images-idx3-ubyte.gz")
print(X_test.shape)
y_test = labels_file_read("/content/drive/MyDrive/SML/mnist/t10k-labels-idx1-ubyte.gz")
# y_test = list(y_test)

X_train = X_train.reshape(60000,28*28)
X_test = X_test.reshape(10000,28*28)

iterations = 5
learning_rate = 0.1
trees = []

# F0 = y_train.mean()
# Fm = F0
# trees = []
# for _ in range(5):
#     tree = DecisionTreeRegressor()
#     tree.fit(X_train, y_train - Fm)
#     Fm += learning_rate * tree.predict(X_train)
#     trees.append(tree)
# final_prediction = F0 + learning_rate * np.sum([t.predict(X_train) for t in trees], axis=0)
# print(final_prediction)
# for i in range(len(final_prediction)):
#   final_prediction[i] = round(final_prediction[i])
# print(accuracy(list(final_prediction), list(y_train)))

# base_model = DecisionTreeRegressor(max_depth = 1)
# base_model = base_model.fit(X_train, y_train)
# prediction = base_model.predict(X_train)
# trees.append(base_model)

prediction = 0

for i in range(iterations):
  residue = y_train-(learning_rate*prediction)
  print(residue)
  model = DecisionTreeRegressor(max_depth=1)
  model = model.fit(X_train, residue)
  prediction = model.predict(X_train)
  trees.append(model)

# y_train

"""![image.png](data:image/png;base64,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BpBXVhxcvwF80GkEta7JioPPr97A3xqv4Utzq9tPTZBxZFz5Hfndz7+44db3bMm0yjQTUX/5HPUn/oSSVzdh15lRiP5xFLspEBERERENEK+sOKj72LPWBlJraxs+vXoDTVeuQ+NzU5ctDRzJuPI78rufiXnIJy14QsaWaSai/tKA8tw8vHnGjKn/uhI/+54bgywQEREREVGf8MoxDt7+i2eDIirdFL5sRXXd56isacZojYdNBlTXzG2YFuKL0InfwK23+ng01sG4McD876lviIiIiIiIiIYJr2txIAdF9PRJCrLi4Lq5FWYxjejF4wfld+U85Lw87a4g0yzTTkRERERERDSceF3FQVOz+sIDypMRvKDdRE/STkREREREROTNvK7i4IpJfeGBrh656IkbrZZKiJ7qSdqJiIiIiIiIvJnXVRx8dk194SGN5mbccosPWntx4y+HexgxwkdMN/eoBUNP005ERERERETkrbyu4sD0pfrCA/Imf+RIH2hH+0Az4qYetRqQ3xk18maMuc0HIzWeDYxo1ZO0ExEREREREXkzr6s4+PKG+sID8ib/5ptvgp/vCNw1diTMrW0ePc5RxpXfkd+V8/Dx6VnHh56knYiIiIiIiMibeV3FwVet6gsPycqDO++4Fffe8w3lMQuetBhQ4orvyO/KefSktYHU07QTEREREREReSuvqzjojVtuuQn+d47ErAfugFncxLsz3oGMI+PK78jvynkQERERERERkYXXVRzc4qO+6AHZUkAOkhj0rdGYMfl23DbKBzda25Sp9euOZgTytTVcxpFx5Xfkd3va2kDqTdqJiIiIiIiIvNFNbfJRAl6ksBK42geDDH755Vdo/OQ6Pm0246rpBkzXvsKXsmmBcKtGDqR4C8ZoR+AOXw0C7hyJW2+9RfmsN8bcCsRNU98QERERERERDQNeV3FwuBpo/Ex90ws332x5UkLLl19ZKg6+cKg4uM1ScTDq1lva4/ZWwO3AvFD1DREREREREdEw4HUVByc+Av7nkvqml25yGK5AVhBIjpUEfbUFvnsXMP0e9Q0RERERERHRMOB1YxyM1aoveklWBsg6ETl9/bUc4+Br3PjKMsnXMsz6uYzbF/oq7URERERERETewutaHHxxHfjN++obD8jWBNYWBnKNWlpalS4KX1wTU8tXuH7dvpnByJE347ZRt+C20SOU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)"""

final_prediction = learning_rate * np.sum([t.predict(X_train) for t in trees], axis=0)
for i in range(len(final_prediction)):
  final_prediction[i] = round(final_prediction[i])
print('Training accuracy:', accuracy(list(final_prediction), list(y_train)))

test = learning_rate*np.sum([t.predict(X_test) for t in trees], axis=0)
# print(test)
for i in range(len(test)):
  test[i] = round(test[i])
print('Testing accuracy:', accuracy(list(test), list(y_test)))

for i in range(len(trees)):
  name = 'Q1_tree'
  name += str(i+1)
  with open(name, 'wb') as file:
    pickle.dump(name, file)

"""#Question 2"""

df_train = pd.read_csv("/content/drive/MyDrive/SML/fminst/fashion-mnist_train.csv")
df_test = pd.read_csv("/content/drive/MyDrive/SML/fminst/fashion-mnist_test.csv")

X_train = df_train.loc[ : , df_train.columns != 'label']
y_train = pd.DataFrame(df_train['label'])

X_test = df_test.loc[ : , df_test.columns != 'label']
y_test = pd.DataFrame(df_test['label'])

X_train = X_train.to_numpy()
y_train = y_train.to_numpy()
X_test = X_test.to_numpy()
y_test = y_test.to_numpy()

model = Sequential()

model.add(Dense(512, input_dim=784, trainable=True,activation='sigmoid', use_bias=True, 
                kernel_initializer=initializers.he_normal(seed=None)))

model.add(Dense(128, input_dim=512, trainable=True,activation='sigmoid', use_bias=True, 
                kernel_initializer=initializers.he_normal(seed=None)))

model.add(Dense(64, input_dim=128, trainable=True,activation='sigmoid', use_bias=True, 
                kernel_initializer=initializers.he_normal(seed=None)))

model.add(Dense(32, input_dim=128, trainable=True,activation='sigmoid', use_bias=True, 
                kernel_initializer=initializers.he_normal(seed=None)))

model.add(Dense(10, input_dim=32, trainable=True,activation='softmax', use_bias=True, 
                kernel_initializer=initializers.he_normal(seed=None)))

sgd = tf.keras.optimizers.SGD(learning_rate=0.01, momentum=0.9)

model.compile(
  optimizer=sgd,
  loss='categorical_crossentropy',
  metrics=['accuracy'],
)

model.summary()

history = model.fit(X_train, to_categorical(y_train), batch_size=700, epochs=28) #batch sie = 700

"""
The hyperparameters assumed other than those mentioned in the question are: trainable=True, use_bias=True, activation=`sigmoid` for all the layers other than the output layer where activation=`softmax`

Batch size=700, number of epochs=28 and learning rate=0.01
"""

model.save('Q2.h5')

x_axis = []
y_axis = []

for i in range(len(history.history['loss'])):
  x_axis.append(i)
  y_axis.append(history.history['loss'][i])

plt.plot(x_axis, y_axis)
plt.title('Epoch wise training loss')
plt.xlabel('Number of Epoch')
plt.ylabel('Training Loss')
plt.show()

predictions = model.predict(X_test)
y_pred = np.argmax(predictions, axis=1)
y_pred = list(y_pred)
y_test = y_test.reshape(10000,)
y_test = list(y_test)

print('Accuracy: ', accuracy(y_pred, y_test))

classWiseAccuracy(y_test,y_pred)

"""#Question 3"""

X_train = images_file_read("/content/drive/MyDrive/SML/mnist/train-images-idx3-ubyte.gz")
# X_train = (X_train/255)-0.5
print(X_train.shape)
y_train = labels_file_read("/content/drive/MyDrive/SML/mnist/train-labels-idx1-ubyte.gz")
X_test = images_file_read("/content/drive/MyDrive/SML/mnist/t10k-images-idx3-ubyte.gz")
# X_test = (X_test/255)-0.5
print(X_test.shape)
y_test = labels_file_read("/content/drive/MyDrive/SML/mnist/t10k-labels-idx1-ubyte.gz")

X_train = X_train.reshape(60000,28*28)
X_test = X_test.reshape(10000,28*28)

model = Sequential()

model.add(Dense(512, input_dim=784, activation='relu', trainable=True, use_bias=True)) #trainable=true #use_bias=true

model.add(Dense(128, input_dim=512, activation='relu', trainable=True, use_bias=True))

model.add(Dense(64, input_dim=128, activation='relu', trainable=True, use_bias=True))

model.add(Dense(128, input_dim=64, activation='relu', trainable=True, use_bias=True))

model.add(Dense(512, input_dim=128, activation='relu', trainable=True, use_bias=True))

model.add(Dense(784, input_dim=512, activation='relu', trainable=True, use_bias=True))

adam = tf.keras.optimizers.Adam(learning_rate=0.001) #learning_rate=0.001

model.compile(
  optimizer=adam,
  loss='mean_squared_error',
  metrics=['accuracy']
)

model.summary()

history = model.fit(X_train, X_train, batch_size=512, epochs=30)

model.save('Q3_Autoencoder.h5')

x_axis = []
y_axis = []

for i in range(len(history.history['loss'])):
  x_axis.append(i)
  y_axis.append(history.history['loss'][i])

plt.plot(x_axis, y_axis)
plt.title('Epoch wise training loss')
plt.xlabel('Number of Epoch')
plt.ylabel('Training Loss')
plt.show()

model = Sequential()

model.add(Dense(512, input_dim=784, activation='relu', trainable=False, use_bias=True)) #trainable=true #use_bias=true

model.add(Dense(128, input_dim=512, activation='relu', trainable=False, use_bias=True))

model.add(Dense(64, input_dim=128, activation='relu', trainable=False, use_bias=True))

model.add(Dense(32, input_dim=64, activation='relu', trainable=True, use_bias=True))

model.add(Dense(10, input_dim=32, activation='softmax', trainable=True, use_bias=True))

adam = tf.keras.optimizers.Adam(learning_rate=0.001) #learning_rate=0.001

model.compile(
  optimizer=adam,
  loss='categorical_crossentropy',
  metrics=['accuracy']
)

model.summary()

history = model.fit(X_train, to_categorical(y_train), batch_size=100, epochs=30)

model.save('MNISTClassificationModel.h5')

x_axis = []
y_axis = []

for i in range(len(history.history['loss'])):
  x_axis.append(i)
  y_axis.append(history.history['loss'][i])

plt.plot(x_axis, y_axis)
plt.title('Epoch wise training loss')
plt.xlabel('Number of Epoch')
plt.ylabel('Training Loss')
plt.show()

predictions = model.predict(X_test)
y_pred = np.argmax(predictions, axis=1)
y_pred = list(y_pred)
y_test = y_test.reshape(10000,)
y_test = list(y_test)

print('Accuracy:', accuracy(y_pred, y_test))

classWiseAccuracy(y_test, y_pred)

"""#Question 4"""

X_train = images_file_read("/content/drive/MyDrive/SML/mnist/train-images-idx3-ubyte.gz")
print(X_train.shape)
y_train = labels_file_read("/content/drive/MyDrive/SML/mnist/train-labels-idx1-ubyte.gz")
X_test = images_file_read("/content/drive/MyDrive/SML/mnist/t10k-images-idx3-ubyte.gz")
print(X_test.shape)
y_test = labels_file_read("/content/drive/MyDrive/SML/mnist/t10k-labels-idx1-ubyte.gz")

X_train = X_train.reshape(60000,28*28)
X_test = X_test.reshape(10000,28*28)

dataset1 = np.zeros((60000,28*28))
y1 = []

dataset2 = np.zeros((60000,28*28))
y2 = []

dataset3 = np.zeros((60000,28*28))
y3 = []

notVal1 = []
notVal2 = []
notVal3 = []

for i in range(60000):

  index1 = random.randint(0,59999)
  if index1 not in notVal1:
    notVal1.append(index1)

  index2 = random.randint(0,59999)
  if index2 not in notVal2:
    notVal2.append(index2)

  index3 = random.randint(0,59999)
  if index3 not in notVal3:
    notVal3.append(index3)

  dataset1[i] = X_train[index1]
  y1.append(y_train[index1])

  dataset2[i] = X_train[index2]
  y2.append(y_train[index2])

  dataset3[i] = X_train[index3]
  y3.append(y_train[index3])

val1 = np.zeros((60000-len(notVal1),28*28))
y_val1 = []

val2 = np.zeros((60000-len(notVal2),28*28))
y_val2 = []

val3 = np.zeros((60000-len(notVal3),28*28))
y_val3 = []

j1 = 0
j2 = 0
j3 = 0

for i in range(60000):

  if i not in notVal1 and j1<60000-len(notVal1):
    val1[j1] = X_train[i]
    y_val1.append(y_train[i])
    j1 += 1

  if i not in notVal2 and j2<60000-len(notVal2):
    val2[j2] = X_train[i]
    y_val2.append(y_train[i])
    j2 += 1

  if i not in notVal3 and j3<60000-len(notVal3):
    val3[j3] = X_train[i]
    y_val3.append(y_train[i])
    j3 += 1

print(val1.shape)
print(val2.shape)
print(val3.shape)
print(len(notVal1))
print(len(notVal2))
print(len(notVal3))

"""3 Decision Trees have to be made."""

clf1 = DecisionTreeClassifier()
clf1 = clf1.fit(dataset1,y1)

clf2 = DecisionTreeClassifier()
clf2 = clf2.fit(dataset2,y2)

clf3 = DecisionTreeClassifier()
clf3 = clf3.fit(dataset3,y3)

with open('Q4_clf1', 'wb') as file:
  pickle.dump(clf1, file)

with open('Q4_clf2', 'wb') as file:
  pickle.dump(clf2, file)

with open('Q4_clf3', 'wb') as file:
  pickle.dump(clf3, file)

y_pred1 = clf1.predict(X_test)
y_pred2 = clf2.predict(X_test)
y_pred3 = clf3.predict(X_test)

num = 0
final_pred = [-1]*len(y_test)

for i in range(len(y_test)):

  a = y_pred1[i]
  b = y_pred2[i]
  c = y_pred3[i]

  ans = y_test[i]

  if a==b and b==c:
    if a==ans:
      final_pred[i] = ans
      num += 1
  elif a==b and b!=c:
    if a==ans:
      final_pred[i] = ans
      num += 1
  elif b==c and c!=a:
    if b==ans:
      final_pred[i] = ans
      num += 1
  elif c==a and a!=b:
    if c==ans:
      final_pred[i] = ans
      num += 1
  else:
    if a==ans:
      final_pred[i] = ans
      num += 1

num = num*1.0

print('Accuracy:', accuracy(final_pred, list(y_test)))

classWiseAccuracy(list(y_test), final_pred)